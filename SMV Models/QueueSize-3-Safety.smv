MODULE main
VAR state : {s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14};
inp : {ofer0, ofer1, pol, size};
out : {true, nul, 0, 1, 2, ful, 3, empty, null, Queue};
ASSIGN
init(state) := s0;
next(state) := case
state = s0 & inp = ofer0: s1;
state = s0 & inp = ofer1: s2;
state = s0 & inp = pol: s0;
state = s0 & inp = size: s0;
state = s1 & inp = ofer0: s3;
state = s1 & inp = ofer1: s7;
state = s1 & inp = pol: s0;
state = s1 & inp = size: s1;
state = s2 & inp = ofer0: s4;
state = s2 & inp = ofer1: s8;
state = s2 & inp = pol: s0;
state = s2 & inp = size: s2;
state = s3 & inp = ofer0: s5;
state = s3 & inp = ofer1: s12;
state = s3 & inp = pol: s1;
state = s3 & inp = size: s3;
state = s4 & inp = ofer0: s6;
state = s4 & inp = ofer1: s13;
state = s4 & inp = pol: s1;
state = s4 & inp = size: s4;
state = s5 & inp = ofer0: s5;
state = s5 & inp = ofer1: s5;
state = s5 & inp = pol: s3;
state = s5 & inp = size: s5;
state = s6 & inp = ofer0: s6;
state = s6 & inp = ofer1: s6;
state = s6 & inp = pol: s3;
state = s6 & inp = size: s6;
state = s7 & inp = ofer0: s9;
state = s7 & inp = ofer1: s14;
state = s7 & inp = pol: s2;
state = s7 & inp = size: s7;
state = s8 & inp = ofer0: s10;
state = s8 & inp = ofer1: s11;
state = s8 & inp = pol: s2;
state = s8 & inp = size: s8;
state = s9 & inp = ofer0: s9;
state = s9 & inp = ofer1: s9;
state = s9 & inp = pol: s4;
state = s9 & inp = size: s9;
state = s10 & inp = ofer0: s10;
state = s10 & inp = ofer1: s10;
state = s10 & inp = pol: s4;
state = s10 & inp = size: s10;
state = s11 & inp = ofer0: s11;
state = s11 & inp = ofer1: s11;
state = s11 & inp = pol: s8;
state = s11 & inp = size: s11;
state = s12 & inp = ofer0: s12;
state = s12 & inp = ofer1: s12;
state = s12 & inp = pol: s7;
state = s12 & inp = size: s12;
state = s13 & inp = ofer0: s13;
state = s13 & inp = ofer1: s13;
state = s13 & inp = pol: s7;
state = s13 & inp = size: s13;
state = s14 & inp = ofer0: s14;
state = s14 & inp = ofer1: s14;
state = s14 & inp = pol: s8;
state = s14 & inp = size: s14;
esac;
out := case
state = s0 & inp = ofer0: true;
state = s0 & inp = ofer1: true;
state = s0 & inp = pol: nul;
state = s0 & inp = size: 0;
state = s1 & inp = ofer0: true;
state = s1 & inp = ofer1: true;
state = s1 & inp = pol: 0;
state = s1 & inp = size: 1;
state = s2 & inp = ofer0: true;
state = s2 & inp = ofer1: true;
state = s2 & inp = pol: 1;
state = s2 & inp = size: 1;
state = s3 & inp = ofer0: true;
state = s3 & inp = ofer1: true;
state = s3 & inp = pol: 0;
state = s3 & inp = size: 2;
state = s4 & inp = ofer0: true;
state = s4 & inp = ofer1: true;
state = s4 & inp = pol: 1;
state = s4 & inp = size: 2;
state = s5 & inp = ofer0: ful;
state = s5 & inp = ofer1: ful;
state = s5 & inp = pol: 0;
state = s5 & inp = size: 3;
state = s6 & inp = ofer0: ful;
state = s6 & inp = ofer1: ful;
state = s6 & inp = pol: 1;
state = s6 & inp = size: 3;
state = s7 & inp = ofer0: true;
state = s7 & inp = ofer1: true;
state = s7 & inp = pol: 0;
state = s7 & inp = size: 2;
state = s8 & inp = ofer0: true;
state = s8 & inp = ofer1: true;
state = s8 & inp = pol: 1;
state = s8 & inp = size: 2;
state = s9 & inp = ofer0: ful;
state = s9 & inp = ofer1: ful;
state = s9 & inp = pol: 0;
state = s9 & inp = size: 3;
state = s10 & inp = ofer0: ful;
state = s10 & inp = ofer1: ful;
state = s10 & inp = pol: 1;
state = s10 & inp = size: 3;
state = s11 & inp = ofer0: ful;
state = s11 & inp = ofer1: ful;
state = s11 & inp = pol: 1;
state = s11 & inp = size: 3;
state = s12 & inp = ofer0: ful;
state = s12 & inp = ofer1: ful;
state = s12 & inp = pol: 0;
state = s12 & inp = size: 3;
state = s13 & inp = ofer0: ful;
state = s13 & inp = ofer1: ful;
state = s13 & inp = pol: 1;
state = s13 & inp = size: 3;
state = s14 & inp = ofer0: ful;
state = s14 & inp = ofer1: ful;
state = s14 & inp = pol: 0;
state = s14 & inp = size: 3;
esac;
--Safety Properties....Something Bad (Undesired-Behavior) is not happened 
	--Example-1: It should never be the case that the two processes "proc1" and "proc2" are at the same time in the critical state.... AG ! (proc1.state = critical & proc2.state = critical)
	--Example-2: It is impossible to get to a state where "Started" holds, but "Ready" does not hold.... G!(Started & !Ready)
	--Example-3: It never happens that a "Train-arrives" and the "Bar is up".... G!(Train-arrives & Bar is up)
	--Example-4: It never happens that a "Reactor_temp" go beyond "1000".... AG!(Reactor_temp > 1000)
	--Example-5: G!(One_way & N (Other_way))
	--Example-6: G!(NN(x=0) & NN(y=z+x))	

----------********NOTE:	Bellow are three ways to specify CTL Specifications-- ***********----------
	--SPEC AG((state=s0 & (inp=ofer0 | inp=ofer1)) -> AF(state=s1 | state=s2))	
	--CTLSPEC AG((state=s0 & (inp=ofer0 | inp=ofer1)) -> AF(state=s1 | state=s2))	
	--CTLSPEC NAME X_P5 := AG((state=s0 & (inp=ofer0 | inp=ofer1)) -> AF(state=s1 | state=s2))	
----------*************************************************************************-------------
	

--Properties

--DEFINE QueueIsEmpty:= (inp=pol & out=empty) | (inp=size & out=0); --generating ambiguous warning

DEFINE Queue-Fixed-Size:= 3;
DEFINE EmptyQueue:= (inp=size & out=0) | (inp=pol & out=null) | (state=s0 & inp=ofer0 & out=0) | (state=s0 & inp=ofer1 & out=1); 
DEFINE FullQueue:= (inp=ofer0 & out=ful) | (inp=ofer1 & out=ful) | (inp=size & out=Queue-Fixed-Size);



--P1: It is never the case that the "Queue" indicates both "Empty" and "Full" simultaneously. OR It never happens that the Queue is "Full" and "Empty" simultaneously.	

			CTLSPEC NAME SEC_1_1 := AG!(EmptyQueue & FullQueue)																																	--True
			CTLSPEC NAME SEC_1_2 := AG!(((inp=size & out=0) | (inp=pol & out=null)) & ((inp=ofer0 & out=ful) | (inp=ofer1 & out=ful) | (inp=size & out=Queue-Fixed-Size)))						--True	
			
	
--P2: (a) It is never the case that Queue-size becomes "greater than fixed-size" i.e., (Queue-Size > Queue-Fixed-Size).

			--CTLSPEC NAME SEC_2_1 := AG!(inp=size & out >= Queue-Fixed-Size)							--Suntax Error on " out >= "
			CTLSPEC NAME SEC_2_1 := AG!(inp=size & out=Queue-Fixed-Size+1)								--Or out=Queue-Fixed-Size+5 etc
			CTLSPEC NAME SEC_2_2 := AG EF!(inp=size & out=Queue-Fixed-Size+1)
			LTLSPEC NAME SEC_2_3 := G!(inp=size & out=Queue-Fixed-Size+1)		
	

--P2: (b) It is never the case that the "Queue-size becomes less than zero".

	
			CTLSPEC NAME SEC_2_4 := AG!(inp=size & out=-1)												--size becomes less than zero
			CTLSPEC NAME SEC_2_5 := AG EF!(inp=size & out=-1)
			LTLSPEC NAME SEC_2_6 := G!(inp=size & out=-1)	
		
		
--P3: (a) It is never be the case that the "Queue remains always Empty" except at initial state.

					CTLSPEC NAME SEC_3_1 := AG!((state!=s0) & EmptyQueue)																			--True
					CTLSPEC NAME SEC_3_2 := AG!((inp=size & out!=0) & EmptyQueue)																	--True					
					LTLSPEC NAME SEC_3_3 := G!((state!=s0) & EmptyQueue)																			--True	
					--CTLSPEC NAME SEC_3_4 := AG!((state!=s0 )&(inp=size & out=0))																	--True

					
--P3: (b) It is never the case that the "Queue always remains Full" except at final state.
					LTLSPEC NAME SEC_3_5 := G!((inp=size & out!=Queue-Fixed-Size) & FullQueue)														--True
					CTLSPEC NAME SEC_3_6 := AG!((inp=size & out!=Queue-Fixed-Size) & FullQueue)														--True	
						
					

--P4: (a) It should never be the case that the two operations "offer" and "pol" occur at the same time. 
					LTLSPEC NAME SEC_4_1 := G!((inp=ofer0 & out=0) & (inp=pol & out=0)) 															--True
					LTLSPEC NAME SEC_4_2 := G!(inp=ofer0 & inp=pol)																					--True
					
					--True
					CTLSPEC NAME SEC_4_3 := AG!((inp=ofer0 & out=0) & (inp=pol & out=0))  															--True	
					CTLSPEC NAME SEC_4_4 := AG!(inp=ofer0 & inp=pol)  																				--True	

--P4: (b) It should never be the case that the two operations "ofer0" and "ofer1" occur at the same time. 

					LTLSPEC NAME SEC_4_5 := G!((inp=ofer0 & out=0) & (inp=ofer1 & out=1)) 															--True
					LTLSPEC NAME SEC_4_6 := G!(inp=ofer0 & inp=ofer1)																				--True
					
					CTLSPEC NAME SEC_4_7 := AG!((inp=ofer0 & out=0) & (inp=ofer1 & out=1)) 															--True
					CTLSPEC NAME SEC_4_8 := AG!(inp=ofer0 & inp=ofer1) 																				--True
						

--P5: (a) It is impossible to get to a state where "offer" operations holds, but "pol" does not hold.
				  
				  --I was not successful in writing this specification...

--P5: (b) It is impossible to get to a state where "ofer0" operation holds, but "ofer1" does not hold.
				
				 --I was not successful in writing this specification...

--P6: (a) It never happens that a "offer/pol" operation occurs but/and the Queue is in "Overflows" state.

				  LTLSPEC NAME SEC_6_1:= G!(inp=ofer0 & out=Queue-Fixed-Size+1)
				  LTLSPEC NAME SEC_6_2:= G!(inp=pol & out=Queue-Fixed-Size+1)

				  CTLSPEC NAME SEC_6_3:= AG!(inp=ofer0 & out=Queue-Fixed-Size+1)
				  CTLSPEC NAME SEC_6_4:= AG!(inp=pol & out=Queue-Fixed-Size+1)				  
	
--P6: (b) It never happens that a "offer/pol" operation occurs but/and the Queue is in "Underflow" state.
				  LTLSPEC NAME SEC_6_5:= G!(inp=ofer0 & out=-1)
				  LTLSPEC NAME SEC_6_6:= G!(inp=pol & out=-1)
				  
				  CTLSPEC NAME SEC_6_7:= AG!(inp=ofer0 & out=-1)
				  CTLSPEC NAME SEC_6_8:= AG!(inp=pol & out=-1)

--P7: It is never the case that the behaviour of "offer/pol" operation is different in different state.
										 
				 LTLSPEC NAME SEC_7_1:= G!((inp=ofer0 & out=0) & X(!FullQueue & inp=ofer0 & out=1))													--True				 
				 --LTLSPEC NAME SEC_7_2:= G!((inp=ofer0 & out=0) & X(inp=ofer0 & out=0))															--False				 
				 LTLSPEC NAME SEC_7_3:= G!((inp=ofer0 & out=0) & X(inp=ofer0 & out=1))																--True
				 
				--CTLSPEC NAME SEC_7_4:= AG!((inp=ofer0 & out=0) & X(inp=ofer0 & out=1))															--Error...Can not be written in CTL
						
						
		
