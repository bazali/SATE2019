MODULE main
VAR state : {s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15};
inp : {add1, add2, add3, add4, remov1, remov2, remov3, remov4, size};
out : {Tru, empty, 0, Fls, 1, 2, 3, 4, ful, Set};
ASSIGN
init(state) := s0;
next(state) := case
state = s0 & inp = add1: s1;
state = s0 & inp = add2: s2;
state = s0 & inp = add3: s3;
state = s0 & inp = add4: s4;
state = s0 & inp = remov1: s0;
state = s0 & inp = remov2: s0;
state = s0 & inp = remov3: s0;
state = s0 & inp = remov4: s0;
state = s0 & inp = size: s0;
state = s1 & inp = add1: s1;
state = s1 & inp = add2: s5;
state = s1 & inp = add3: s6;
state = s1 & inp = add4: s7;
state = s1 & inp = remov1: s0;
state = s1 & inp = remov2: s1;
state = s1 & inp = remov3: s1;
state = s1 & inp = remov4: s1;
state = s1 & inp = size: s1;
state = s2 & inp = add1: s5;
state = s2 & inp = add2: s2;
state = s2 & inp = add3: s8;
state = s2 & inp = add4: s9;
state = s2 & inp = remov1: s2;
state = s2 & inp = remov2: s0;
state = s2 & inp = remov3: s2;
state = s2 & inp = remov4: s2;
state = s2 & inp = size: s2;
state = s3 & inp = add1: s6;
state = s3 & inp = add2: s8;
state = s3 & inp = add3: s3;
state = s3 & inp = add4: s10;
state = s3 & inp = remov1: s3;
state = s3 & inp = remov2: s3;
state = s3 & inp = remov3: s0;
state = s3 & inp = remov4: s3;
state = s3 & inp = size: s3;
state = s4 & inp = add1: s7;
state = s4 & inp = add2: s9;
state = s4 & inp = add3: s10;
state = s4 & inp = add4: s4;
state = s4 & inp = remov1: s4;
state = s4 & inp = remov2: s4;
state = s4 & inp = remov3: s4;
state = s4 & inp = remov4: s0;
state = s4 & inp = size: s4;
state = s5 & inp = add1: s5;
state = s5 & inp = add2: s5;
state = s5 & inp = add3: s11;
state = s5 & inp = add4: s12;
state = s5 & inp = remov1: s2;
state = s5 & inp = remov2: s1;
state = s5 & inp = remov3: s5;
state = s5 & inp = remov4: s5;
state = s5 & inp = size: s5;
state = s6 & inp = add1: s6;
state = s6 & inp = add2: s11;
state = s6 & inp = add3: s6;
state = s6 & inp = add4: s13;
state = s6 & inp = remov1: s3;
state = s6 & inp = remov2: s6;
state = s6 & inp = remov3: s1;
state = s6 & inp = remov4: s6;
state = s6 & inp = size: s6;
state = s7 & inp = add1: s7;
state = s7 & inp = add2: s12;
state = s7 & inp = add3: s13;
state = s7 & inp = add4: s7;
state = s7 & inp = remov1: s4;
state = s7 & inp = remov2: s7;
state = s7 & inp = remov3: s7;
state = s7 & inp = remov4: s1;
state = s7 & inp = size: s7;
state = s8 & inp = add1: s11;
state = s8 & inp = add2: s8;
state = s8 & inp = add3: s8;
state = s8 & inp = add4: s14;
state = s8 & inp = remov1: s8;
state = s8 & inp = remov2: s3;
state = s8 & inp = remov3: s2;
state = s8 & inp = remov4: s8;
state = s8 & inp = size: s8;
state = s9 & inp = add1: s12;
state = s9 & inp = add2: s9;
state = s9 & inp = add3: s14;
state = s9 & inp = add4: s9;
state = s9 & inp = remov1: s9;
state = s9 & inp = remov2: s4;
state = s9 & inp = remov3: s9;
state = s9 & inp = remov4: s2;
state = s9 & inp = size: s9;
state = s10 & inp = add1: s13;
state = s10 & inp = add2: s14;
state = s10 & inp = add3: s10;
state = s10 & inp = add4: s10;
state = s10 & inp = remov1: s10;
state = s10 & inp = remov2: s10;
state = s10 & inp = remov3: s4;
state = s10 & inp = remov4: s3;
state = s10 & inp = size: s10;
state = s11 & inp = add1: s11;
state = s11 & inp = add2: s11;
state = s11 & inp = add3: s11;
state = s11 & inp = add4: s15;
state = s11 & inp = remov1: s8;
state = s11 & inp = remov2: s6;
state = s11 & inp = remov3: s5;
state = s11 & inp = remov4: s11;
state = s11 & inp = size: s11;
state = s12 & inp = add1: s12;
state = s12 & inp = add2: s12;
state = s12 & inp = add3: s15;
state = s12 & inp = add4: s12;
state = s12 & inp = remov1: s9;
state = s12 & inp = remov2: s7;
state = s12 & inp = remov3: s12;
state = s12 & inp = remov4: s5;
state = s12 & inp = size: s12;
state = s13 & inp = add1: s13;
state = s13 & inp = add2: s15;
state = s13 & inp = add3: s13;
state = s13 & inp = add4: s13;
state = s13 & inp = remov1: s10;
state = s13 & inp = remov2: s13;
state = s13 & inp = remov3: s7;
state = s13 & inp = remov4: s6;
state = s13 & inp = size: s13;
state = s14 & inp = add1: s15;
state = s14 & inp = add2: s14;
state = s14 & inp = add3: s14;
state = s14 & inp = add4: s14;
state = s14 & inp = remov1: s14;
state = s14 & inp = remov2: s10;
state = s14 & inp = remov3: s9;
state = s14 & inp = remov4: s8;
state = s14 & inp = size: s14;
state = s15 & inp = add1: s15;
state = s15 & inp = add2: s15;
state = s15 & inp = add3: s15;
state = s15 & inp = add4: s15;
state = s15 & inp = remov1: s14;
state = s15 & inp = remov2: s13;
state = s15 & inp = remov3: s12;
state = s15 & inp = remov4: s11;
state = s15 & inp = size: s15;
esac;
out := case
state = s0 & inp = add1: Tru;
state = s0 & inp = add2: Tru;
state = s0 & inp = add3: Tru;
state = s0 & inp = add4: Tru;
state = s0 & inp = remov1: empty;
state = s0 & inp = remov2: empty;
state = s0 & inp = remov3: empty;
state = s0 & inp = remov4: empty;
state = s0 & inp = size: 0;
state = s1 & inp = add1: Fls;
state = s1 & inp = add2: Tru;
state = s1 & inp = add3: Tru;
state = s1 & inp = add4: Tru;
state = s1 & inp = remov1: 1;
state = s1 & inp = remov2: Fls;
state = s1 & inp = remov3: Fls;
state = s1 & inp = remov4: Fls;
state = s1 & inp = size: 1;
state = s2 & inp = add1: Tru;
state = s2 & inp = add2: Fls;
state = s2 & inp = add3: Tru;
state = s2 & inp = add4: Tru;
state = s2 & inp = remov1: Fls;
state = s2 & inp = remov2: 2;
state = s2 & inp = remov3: Fls;
state = s2 & inp = remov4: Fls;
state = s2 & inp = size: 1;
state = s3 & inp = add1: Tru;
state = s3 & inp = add2: Tru;
state = s3 & inp = add3: Fls;
state = s3 & inp = add4: Tru;
state = s3 & inp = remov1: Fls;
state = s3 & inp = remov2: Fls;
state = s3 & inp = remov3: 3;
state = s3 & inp = remov4: Fls;
state = s3 & inp = size: 1;
state = s4 & inp = add1: Tru;
state = s4 & inp = add2: Tru;
state = s4 & inp = add3: Tru;
state = s4 & inp = add4: Fls;
state = s4 & inp = remov1: Fls;
state = s4 & inp = remov2: Fls;
state = s4 & inp = remov3: Fls;
state = s4 & inp = remov4: 4;
state = s4 & inp = size: 1;
state = s5 & inp = add1: Fls;
state = s5 & inp = add2: Fls;
state = s5 & inp = add3: Tru;
state = s5 & inp = add4: Tru;
state = s5 & inp = remov1: 1;
state = s5 & inp = remov2: 2;
state = s5 & inp = remov3: Fls;
state = s5 & inp = remov4: Fls;
state = s5 & inp = size: 2;
state = s6 & inp = add1: Fls;
state = s6 & inp = add2: Tru;
state = s6 & inp = add3: Fls;
state = s6 & inp = add4: Tru;
state = s6 & inp = remov1: 1;
state = s6 & inp = remov2: Fls;
state = s6 & inp = remov3: 3;
state = s6 & inp = remov4: Fls;
state = s6 & inp = size: 2;
state = s7 & inp = add1: Fls;
state = s7 & inp = add2: Tru;
state = s7 & inp = add3: Tru;
state = s7 & inp = add4: Fls;
state = s7 & inp = remov1: 1;
state = s7 & inp = remov2: Fls;
state = s7 & inp = remov3: Fls;
state = s7 & inp = remov4: 4;
state = s7 & inp = size: 2;
state = s8 & inp = add1: Tru;
state = s8 & inp = add2: Fls;
state = s8 & inp = add3: Fls;
state = s8 & inp = add4: Tru;
state = s8 & inp = remov1: Fls;
state = s8 & inp = remov2: 2;
state = s8 & inp = remov3: 3;
state = s8 & inp = remov4: Fls;
state = s8 & inp = size: 2;
state = s9 & inp = add1: Tru;
state = s9 & inp = add2: Fls;
state = s9 & inp = add3: Tru;
state = s9 & inp = add4: Fls;
state = s9 & inp = remov1: Fls;
state = s9 & inp = remov2: 2;
state = s9 & inp = remov3: Fls;
state = s9 & inp = remov4: 4;
state = s9 & inp = size: 2;
state = s10 & inp = add1: Tru;
state = s10 & inp = add2: Tru;
state = s10 & inp = add3: Fls;
state = s10 & inp = add4: Fls;
state = s10 & inp = remov1: Fls;
state = s10 & inp = remov2: Fls;
state = s10 & inp = remov3: 3;
state = s10 & inp = remov4: 4;
state = s10 & inp = size: 2;
state = s11 & inp = add1: Fls;
state = s11 & inp = add2: Fls;
state = s11 & inp = add3: Fls;
state = s11 & inp = add4: Tru;
state = s11 & inp = remov1: 1;
state = s11 & inp = remov2: 2;
state = s11 & inp = remov3: 3;
state = s11 & inp = remov4: Fls;
state = s11 & inp = size: 3;
state = s12 & inp = add1: Fls;
state = s12 & inp = add2: Fls;
state = s12 & inp = add3: Tru;
state = s12 & inp = add4: Fls;
state = s12 & inp = remov1: 1;
state = s12 & inp = remov2: 2;
state = s12 & inp = remov3: Fls;
state = s12 & inp = remov4: 4;
state = s12 & inp = size: 3;
state = s13 & inp = add1: Fls;
state = s13 & inp = add2: Tru;
state = s13 & inp = add3: Fls;
state = s13 & inp = add4: Fls;
state = s13 & inp = remov1: 1;
state = s13 & inp = remov2: Fls;
state = s13 & inp = remov3: 3;
state = s13 & inp = remov4: 4;
state = s13 & inp = size: 3;
state = s14 & inp = add1: Tru;
state = s14 & inp = add2: Fls;
state = s14 & inp = add3: Fls;
state = s14 & inp = add4: Fls;
state = s14 & inp = remov1: Fls;
state = s14 & inp = remov2: 2;
state = s14 & inp = remov3: 3;
state = s14 & inp = remov4: 4;
state = s14 & inp = size: 3;
state = s15 & inp = add1: ful;
state = s15 & inp = add2: ful;
state = s15 & inp = add3: ful;
state = s15 & inp = add4: ful;
state = s15 & inp = remov1: 1;
state = s15 & inp = remov2: 2;
state = s15 & inp = remov3: 3;
state = s15 & inp = remov4: 4;
state = s15 & inp = size: 4;
esac;
-- Set size is determined by "add operations" (e.g., for add1 and add2, set size will be 2).

DEFINE Set-Fixed-Size:= 4;
DEFINE EmptySet:= (inp=size & out=0) | (state=s0 & inp=remov1 & out=empty)|(state=s0 & inp=remov2 & out=empty) | (state=s0 & inp=add1 & out=Tru)| (state=s0 & inp=add2 & out=Tru) ; 
DEFINE FullSet:= (inp=add1 & out=ful) | (inp=add2 & out=ful) | (inp=size & out=Set-Fixed-Size);
DEFINE Set-Overflow:= Set-Fixed-Size+1;
DEFINE Set-Underflow:= -1;


--In Functional specifications, MUST or SHOULD statements are met.

--P11: Set must not contain duplicated elements.
	
			
			LTLSPEC NAME Fun_1_2 := G(inp=add1 -> X(inp=add1 -> out!=Tru))																									--True
			LTLSPEC NAME Fun_1_3 := G(inp=add2 -> X(inp=add2 -> out!=Tru))																									--True
		
		
--P12(a): It should only be 'Empty' at initial state.  Or It should not be 'Empty' everywhere except at initial state.
	 
			LTLSPEC NAME Fun_2_1 := G(state !=s0 -> !EmptySet)																												--True
			LTLSPEC NAME Fun_2_2 := G((inp=size & out!=0) -> !EmptySet)																										--True		
	 
--P12(b): It should only be 'Filled' at final state. Or It should not be 'Filled' everywhere except at final state.
		
			LTLSPEC NAME Fun_2_3 := G((inp=size & out!=Set-Fixed-Size) -> !FullSet)	
			LTLSPEC NAME Fun_2_4 := G((inp=size & out!=Set-Fixed-Size) -> !FullSet)
	 
	 
--P13(a): "Add" operation increases the Set-size.
			
			--Adding
			LTLSPEC NAME Fun_3_1 := G((inp=add1|inp=add2) -> X(inp=size ->out!=0))
				
			--LTLSPEC NAME Fun_3_2 := G((inp=add1|inp=add2) -> X(inp=size -> out=1|out=2|out=3))			
			--CTLSPEC NAME Fun_3_3 := AG((!FullSet & (inp=add1 | inp=add2) & inp!=remov1) -> AF (out=0 | out=1 | out=ful))													--True		
			--CTLSPEC NAME Fun_3_4 := AG((EmptySet & (inp=add1 | inp=add2) & inp!=remov1) -> AF (out=0 | out=1))															--True
		
			--CTLSPEC NAME Fun_3_5 := AG((inp=add1 & inp!=remov1) -> AF (out=0 | out=ful))																					--True
			--CTLSPEC NAME Fun_3_6 := AG(((inp=add1 | inp=add2) & inp!=remov1) -> AF (out=0 | out=1| out=ful))																--True			
				
			
			LTLSPEC NAME Fun_3_7 := G((inp=size & out=0) -> X((inp=add1 | inp=add2) -> X(inp=size -> out=1)))																--True
			
			--LTLSPEC NAME Fun_3_8 := G((inp=size & out=0) -> X(inp=add1 | inp=add2 -> X(!FullSet & (inp=add1 | inp=add2) -> X(inp=size -> out=2))))						--True for Queue and Stack but not for set
	
			LTLSPEC NAME Fun_3_8 := G((inp=size & out=0) -> X(inp=add1 -> X(inp=add2 -> X(inp=size -> out=2))))																--True
			
			--LTLSPEC NAME Fun_3_9 := G((inp=size & out=1) -> X(inp=add1 -> X(inp=add2 -> X(inp=size -> out=3))))															--True	
			
			--For Set-size=2
			--LTLSPEC NAME Fun_3_10 := G((inp=size & out=(Set-Fixed-Size)-1) -> X(inp=add1 -> X(inp=add2 -> X(inp=size -> out=(Set-Fixed-Size)))))
			--LTLSPEC NAME Fun_3_11 := G((inp=size & out=(Set-Fixed-Size)-2) -> X(inp=add1 -> X(inp=add2 -> X(inp=size -> out=(Set-Fixed-Size)))))

			
--P13(b): “Remove" operation decreases the Set-size.
			
			--remov1ing			
			LTLSPEC NAME Fun_3_12 := G((inp=remov1 | inp=remov2) -> X(inp=size -> out!=Set-Fixed-Size))																								--True
			--LTLSPEC NAME Fun_3_11 := G(inp=remov1 -> X(inp=size -> out=0|out=1|out=2))
			
			LTLSPEC NAME Fun_3_13 := G((inp=size & out=Set-Fixed-Size) -> X((inp=remov1 | inp=remov2) -> X(inp=size -> out=(Set-Fixed-Size)-1)))													--True
			--LTLSPEC NAME Fun_3_13 := G((inp=size & out=Set-Fixed-Size) -> X((inp=remov1 | inp=remov2) -> X((inp=remov1 | inp=remov2) ->X(inp=size -> out=(Set-Fixed-Size)-2))))					--False
			
			LTLSPEC NAME Fun_3_14 := G((inp=size & out=Set-Fixed-Size) -> X(inp=remov1 -> X(inp=remov2 ->X(inp=size -> out=(Set-Fixed-Size)-2))))													--False
			LTLSPEC NAME Fun_3_15 := G((FullSet) -> X((inp=remov1 | inp=remov2) -> X((inp=remov1 | inp=remov2) ->X(inp=size -> out!=Set-Fixed-Size))))												--True		
			
		
--P14: "Add1" operation must inserts "1" (not 2) on the Set. And "Add2" must inserts "2" (not 1) on the Set.
							
			LTLSPEC NAME Fun_4_1 := G(!FullSet & inp=add1 -> X(inp=remov1 -> out!=Fls))																								--True
			LTLSPEC NAME Fun_4_2 := G(!FullSet & inp=add1 -> X(inp=remov1 -> out=1))																								--True						
			LTLSPEC NAME Fun_4_3 := G(!FullSet & inp=add2 -> X(inp=remov2 -> out=2))																								--True
			
			--LTLSPEC NAME Fun_4_4 := G(!FullSet & inp=add2 -> X(inp=remov1 -> out=Fls))																							--True				
			--LTLSPEC NAME Fun_4_5 := G(inp=add1 | inp=add2 -> out=0|out=ful)																										--True
				
		
--P15: Set should not "Overflow" or "Underflow".
				
			LTLSPEC NAME Fun_5_1 := G((!FullSet & (inp=add1 | inp=add2)) -> X(inp=size -> out!=Set-Overflow))																		--True
			LTLSPEC NAME Fun_5_2 := G(!EmptySet & inp=remov1 -> X(inp=size -> out!=Set-Underflow))			   																		--True
				

--P16: If equal number of "Add" operations followed by same number of "Remove" operations occur then Set-size should remain same. (Can be removed)
				
			--one push followd by one remov1
			--Below two statements are true for Stack/Queue but not for Set
			--LTLSPEC NAME Fun_6_1 := G((inp=size & out=0) -> X((inp=add1 | inp=add2) -> X((inp=remov1 | inp=remov2) -> X(inp=size -> out=0))))	
			--LTLSPEC NAME Fun_6_2 := G((inp=size & out=1) -> X((inp=add1 | inp=add2) -> X((inp=remov1 | inp=remov2) -> X(inp=size -> out=1))))
			
			--for set
			--LTLSPEC NAME Fun_6_1 := G((inp=size & out=0) -> X(inp=add1 -> X(inp=remov1 -> X(inp=size -> out=0))))	
			--LTLSPEC NAME Fun_6_2 := G((inp=size & out=1) -> X(inp=add2 -> X(inp=remov2 -> X(inp=size -> out=1))))																	--False
		
		
			--Two pushes followed by two remov1s	
			--LTLSPEC NAME Fun_6_3 := G((inp=size & out=1) -> X(inp=add1 -> X(!FullSet & inp=add2 -> X(inp=remov1 -> X(inp=remov1 -> X(inp=size -> out=1))))))							--True for Stack/Queue not for Set
			--LTLSPEC NAME Fun_6_4 := G((inp=size & out=2) -> X(inp=add1 -> X(!FullSet & inp=add2 -> X(inp=remov1 -> X(inp=remov1 -> X(inp=size -> out=2))))))							--True for Stack/Queue not for Set
	
			--LTLSPEC NAME Fun_6_5 := G((FullSet) -> X(inp=add1 -> X(!FullSet & inp=add2 -> X(inp=remov1 -> X(inp=remov2 -> X(FullSet))))))												--True	
			--LTLSPEC NAME Fun_6_6 := G((inp=size -> out=0) -> X(inp=add1 -> X(inp=add2 -> X(inp=remov1 -> X(inp=remov2 -> X(inp=size -> out=0))))))												--True				
		
		
			--LTLSPEC NAME SEC_3_9 := G((inp=size & out=0) -> X(inp=add1 -> X(!FullSet & inp=add2 -> X(inp=remov1 -> X(inp=size -> out=2)))))											--False
			--LTLSPEC NAME SEC_3_10 := G((inp=size & out=0) -> X(inp=add1 -> X(!FullSet & inp=add2 -> X(inp=remov1 -> X(inp=size -> out=1)))))											--True
				
	
