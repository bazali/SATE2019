MODULE main
VAR state : {s0,s1,s2,s3,s4,s5,s6,s7};
inp : {add1, add2, add3, remov1, remov2, remov3, size};
out : {Tru, empty, Fls, 0, 1, 3, 2, ful, Set};
ASSIGN
init(state) := s0;
next(state) := case
state = s0 & inp = add1: s1;
state = s0 & inp = add2: s2;
state = s0 & inp = add3: s3;
state = s0 & inp = remov1: s0;
state = s0 & inp = remov2: s0;
state = s0 & inp = remov3: s0;
state = s0 & inp = size: s0;
state = s1 & inp = add1: s1;
state = s1 & inp = add2: s4;
state = s1 & inp = add3: s5;
state = s1 & inp = remov1: s0;
state = s1 & inp = remov2: s1;
state = s1 & inp = remov3: s1;
state = s1 & inp = size: s1;
state = s2 & inp = add1: s4;
state = s2 & inp = add2: s2;
state = s2 & inp = add3: s6;
state = s2 & inp = remov1: s2;
state = s2 & inp = remov2: s0;
state = s2 & inp = remov3: s2;
state = s2 & inp = size: s2;
state = s3 & inp = add1: s5;
state = s3 & inp = add2: s6;
state = s3 & inp = add3: s3;
state = s3 & inp = remov1: s3;
state = s3 & inp = remov2: s3;
state = s3 & inp = remov3: s0;
state = s3 & inp = size: s3;
state = s4 & inp = add1: s4;
state = s4 & inp = add2: s4;
state = s4 & inp = add3: s7;
state = s4 & inp = remov1: s2;
state = s4 & inp = remov2: s1;
state = s4 & inp = remov3: s4;
state = s4 & inp = size: s4;
state = s5 & inp = add1: s5;
state = s5 & inp = add2: s7;
state = s5 & inp = add3: s5;
state = s5 & inp = remov1: s3;
state = s5 & inp = remov2: s5;
state = s5 & inp = remov3: s1;
state = s5 & inp = size: s5;
state = s6 & inp = add1: s7;
state = s6 & inp = add2: s6;
state = s6 & inp = add3: s6;
state = s6 & inp = remov1: s6;
state = s6 & inp = remov2: s3;
state = s6 & inp = remov3: s2;
state = s6 & inp = size: s6;
state = s7 & inp = add1: s7;
state = s7 & inp = add2: s7;
state = s7 & inp = add3: s7;
state = s7 & inp = remov1: s6;
state = s7 & inp = remov2: s5;
state = s7 & inp = remov3: s4;
state = s7 & inp = size: s7;
esac;
out := case
state = s0 & inp = add1: Tru;
state = s0 & inp = add2: Tru;
state = s0 & inp = add3: Tru;
state = s0 & inp = remov1: empty;
state = s0 & inp = remov2: empty;
state = s0 & inp = remov3: Fls;
state = s0 & inp = size: 0;
state = s1 & inp = add1: Fls;
state = s1 & inp = add2: Tru;
state = s1 & inp = add3: Tru;
state = s1 & inp = remov1: Tru;
state = s1 & inp = remov2: Fls;
state = s1 & inp = remov3: Fls;
state = s1 & inp = size: 1;
state = s2 & inp = add1: Tru;
state = s2 & inp = add2: Fls;
state = s2 & inp = add3: Tru;
state = s2 & inp = remov1: Fls;
state = s2 & inp = remov2: Tru;
state = s2 & inp = remov3: Fls;
state = s2 & inp = size: 1;
state = s3 & inp = add1: Tru;
state = s3 & inp = add2: Tru;
state = s3 & inp = add3: Fls;
state = s3 & inp = remov1: Fls;
state = s3 & inp = remov2: Fls;
state = s3 & inp = remov3: 3;
state = s3 & inp = size: 1;
state = s4 & inp = add1: Fls;
state = s4 & inp = add2: Fls;
state = s4 & inp = add3: Tru;
state = s4 & inp = remov1: 1;
state = s4 & inp = remov2: 2;
state = s4 & inp = remov3: Fls;
state = s4 & inp = size: 2;
state = s5 & inp = add1: Fls;
state = s5 & inp = add2: Tru;
state = s5 & inp = add3: Fls;
state = s5 & inp = remov1: 1;
state = s5 & inp = remov2: Fls;
state = s5 & inp = remov3: 3;
state = s5 & inp = size: 2;
state = s6 & inp = add1: Tru;
state = s6 & inp = add2: Fls;
state = s6 & inp = add3: Fls;
state = s6 & inp = remov1: Fls;
state = s6 & inp = remov2: 2;
state = s6 & inp = remov3: 3;
state = s6 & inp = size: 2;
state = s7 & inp = add1: ful;
state = s7 & inp = add2: ful;
state = s7 & inp = add3: ful;
state = s7 & inp = remov1: 1;
state = s7 & inp = remov2: 2;
state = s7 & inp = remov3: 3;
state = s7 & inp = size: 3;
esac;
--Safety Properties....Something Bad (Undesired-Behavior) is not happened 
	--Example-1: It should never be the case that the two processes "proc1" and "proc2" are at the same time in the critical state.... AG ! (proc1.state = critical & proc2.state = critical)
	--Example-2: It is impossible to get to a state where "Started" holds, but "Ready" does not hold.... G!(Started & !Ready)
	--Example-3: It never happens that a "Train-arrives" and the "Bar is up".... G!(Train-arrives & Bar is up)
	--Example-4: It never happens that a "Reactor_temp" go beyond "1000".... AG!(Reactor_temp > 1000)
	--Example-5: G!(One_way & N (Other_way))
	--Example-6: G!(NN(x=0) & NN(y=z+x))	

----------********NOTE:	Bellow are three ways to specify CTL Specifications-- ***********----------
	--SPEC AG((state=s0 & (inp=add1 | inp=add2)) -> AF(state=s1 | state=s2))	
	--CTLSPEC AG((state=s0 & (inp=add1 | inp=add2)) -> AF(state=s1 | state=s2))	
	--CTLSPEC NAME X_P5 := AG((state=s0 & (inp=add1 | inp=add2)) -> AF(state=s1 | state=s2))	
----------*************************************************************************-------------
	

--Properties


-- Set size is determined by "add operations" (e.g., for add1 and add2, set size will be 2).

DEFINE Set-Fixed-Size:= 3;
DEFINE EmptySet:= (inp=size & out=0) | (state=s0 & inp=remov1 & out=empty)|(state=s0 & inp=remov2 & out=empty) | (state=s0 & inp=add1 & out=Tru)| (state=s0 & inp=add2 & out=Tru) ; 
DEFINE FullSet:= (inp=add1 & out=ful) | (inp=add2 & out=ful) | (inp=size & out=Set-Fixed-Size);


--P0: It is never the case that the "Set" contains duplicated elements

			--LTLSPEC NAME SEC_0_1 := ((inp=add1 & out=Tru) -> X(inp=add1 -> out=Fls))	
			--LTLSPEC NAME SEC_0_2 := ((inp=add1 & out=Tru) -> X(inp=add1 & out=Fls))
			--LTLSPEC NAME SEC_0_3 := G((inp=add1 & out=Tru) -> X(inp=add1 -> out=Fls))
			
			--LTLSPEC NAME SEC_0_4 := G((inp=add1 -> out=Tru) -> X(inp=add1 -> out=Tru))			--False
			--LTLSPEC NAME SEC_0_4 := G((inp=add1 -> out=Tru) -> X(inp=add1 -> out=Fls))			--False
			
			--CTLSPEC NAME SEC_0_2 := AG!(((inp=size & out=0) | ((inp=remov1|inp=remov2) & out=empty)) & ((inp=add1 & out=ful) | (inp=add2 & out=ful) | (inp=size & out=Set-Fixed-Size)))					--True	

--P1: It is never the case that the "Set" indicates both "Empty" and "Full" simultaneously. OR It never happens that the Set is "Full" and "Empty" simultaneously.	

			CTLSPEC NAME SEC_1_1 := AG!(EmptySet & FullSet)																																				--True
			CTLSPEC NAME SEC_1_2 := AG!(((inp=size & out=0) | ((inp=remov1|inp=remov2) & out=empty)) & ((inp=add1 & out=ful) | (inp=add2 & out=ful) | (inp=size & out=Set-Fixed-Size)))					--True	
			
	
--P2: (a) It is never the case that Set-size becomes "greater than fixed-size" i.e., (Set-Size > Set-Fixed-Size).

			
			CTLSPEC NAME SEC_2_1 := AG!(inp=size & out=(Set-Fixed-Size)+1)																		--Or out=Set-Fixed-Size+5 etc
			CTLSPEC NAME SEC_2_2 := AG EF!(inp=size & out=(Set-Fixed-Size+1))
			LTLSPEC NAME SEC_2_3 := G!(inp=size & out=(Set-Fixed-Size)+1)		
	

--P2: (b) It is never the case that the "Set-size becomes less than zero".

	
			CTLSPEC NAME SEC_2_4 := AG!(inp=size & out=-1)																						--size becomes less than zero
			CTLSPEC NAME SEC_2_5 := AG EF!(inp=size & out=-1)
			LTLSPEC NAME SEC_2_6 := G!(inp=size & out=-1)	
		
		
--P3: (a) It is never be the case that the "Set remains always Empty" except at initial state.

					CTLSPEC NAME SEC_3_1 := AG!((state!=s0) & EmptySet)																			--True
					CTLSPEC NAME SEC_3_2 := AG!((inp=size & out!=0) & EmptySet)																	--True					
					LTLSPEC NAME SEC_3_3 := G!((state!=s0) & EmptySet)																			--True	
					--CTLSPEC NAME SEC_3_4 := AG!((state!=s0 )&(inp=size & out=0))																--True

					
--P3: (b) It is never the case that the "Set always remains Full" except at final state.
					LTLSPEC NAME SEC_3_5 := G!((inp=size & out!=Set-Fixed-Size) & FullSet)														--True
					CTLSPEC NAME SEC_3_6 := AG!((inp=size & out!=Set-Fixed-Size) & FullSet)														--True	
						
					

--P4: (a) It should never be the case that the two operations "Add" and "Remove" occur at the same time. 
					LTLSPEC NAME SEC_4_1 := G!((inp=add1 & out=Tru) & (inp=remov1 & out=Tru)) 													--True
					LTLSPEC NAME SEC_4_2 := G!(inp=add1 & inp=remov1)																			--True
					
					--True
					CTLSPEC NAME SEC_4_3 := AG!((inp=add1 & out=Tru) & (inp=remov1 & out=Tru))  												--True	
					CTLSPEC NAME SEC_4_4 := AG!(inp=add1 & inp=remov1)  																		--True	
					

--P4: (b) It should never be the case that the two operations "Add0" and "Add1" occur at the same time. 

					LTLSPEC NAME SEC_4_5 := G!((inp=add1 & out=Tru) & (inp=add2 & out=Tru)) 													--True
					LTLSPEC NAME SEC_4_6 := G!(inp=add1 & inp=add2)																				--True
					
					CTLSPEC NAME SEC_4_7 := AG!((inp=add1 & out=Tru) & (inp=add2 & out=Tru)) 													--True
					CTLSPEC NAME SEC_4_8 := AG!(inp=add1 & inp=add2) 																			--True
					

--P5: (a) It is impossible to get to a state where "Add" operations holds, but "Remove" does not hold.
				  
				  --I was not successful in writing this specification...

--P5: (b) It is impossible to get to a state where "Add0" operation holds, but "Add1" does not hold.
				
				 --I was not successful in writing this specification...

--P6: (a) It never happens that a "Add/Remove" operation occurs but/and the Set is in "Overflows" state.

				  LTLSPEC NAME SEC_6_1:= G!(inp=add1 & out=(Set-Fixed-Size)+1)
				  LTLSPEC NAME SEC_6_2:= G!((inp=remov1|inp=remov2) & out=(Set-Fixed-Size)+1)

				  CTLSPEC NAME SEC_6_3:= AG!(inp=add1 & out=(Set-Fixed-Size)+1)
				  CTLSPEC NAME SEC_6_4:= AG!((inp=remov1|inp=remov2) & out=(Set-Fixed-Size)+1)				  
	
--P6: (b) It never happens that a "Add/Remove" operation occurs but/and the Set is in "Underflow" state.
				  LTLSPEC NAME SEC_6_5:= G!(inp=add1 & out=-1)
				  LTLSPEC NAME SEC_6_6:= G!((inp=remov1|inp=remov2) & out=-1)
				  
				  CTLSPEC NAME SEC_6_7:= AG!(inp=add1 & out=-1)
				  CTLSPEC NAME SEC_6_8:= AG!((inp=remov1|inp=remov2) & out=-1)					
		
